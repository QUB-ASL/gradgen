// This file is automatically generated by GradGen

use casadi_{{name}}::*;

/// Number of states
pub fn num_states() -> usize {
    return NX;
}

/// Number of inputs
pub fn num_inputs() -> usize {
    return NU;
}

#[derive(Debug)]
pub struct BackwardGradientWorkspace {
    pub x_at_node: Vec<f64>,
    pub a_at_node: Vec<f64>,
    pub(crate) temp_nx_a: Vec<f64>,
    pub(crate) temp_nx_f: Vec<f64>,
    pub(crate) temp_nx_ell: Vec<f64>,
    pub(crate) temp_nu_f: Vec<f64>,
    pub(crate) temp_nu_ell: Vec<f64>,
}

/// Workspace structure
impl BackwardGradientWorkspace {

    /// Create new instance of workspaces
    ///
    /// # Arguments
    ///
    /// * `r` - storage for state (NX) sized variable
    /// * `x_at_node` - vector of states: consists of state at node [index] for nodes(0, N)
    /// * `a_at_node` - vector of adjoints: consists of adjoint at node [index] for nodes(1, N)
    ///
    pub fn new() -> BackwardGradientWorkspace {
        BackwardGradientWorkspace {
            x_at_node: vec![0.0; NX * NUM_NODES],
            a_at_node: vec![0.0; NX * NUM_NODES],
            temp_nx_a: vec![0.0; NX],
            temp_nx_f: vec![0.0; NX],
            temp_nx_ell: vec![0.0; NX],
            temp_nu_f: vec![0.0; NU],
            temp_nu_ell: vec![0.0; NU],
        }
    }
}

fn a_plus_eq_b(a: &mut [f64], b: &[f64]) {
    a.iter_mut().zip(b.iter()).for_each(|(ai, bi)| *ai += *bi);
}

fn a_times_eq_scalar_b(a: &mut [f64], b: &f64) {
    a.iter_mut().for_each(|ai| *ai *= *b);
}

/// Gradient of the total stochastic cost function with backward method
///
/// # Arguments
///
/// * `x0` - initial state (state at node 0)
/// * `u_at_node` - vector of inputs: consists of input at node [index] for nodes(0, N-1)
/// * `grad_stoc` - gradient of total stochastic cost function (result)
/// * `ws` - workspace of type `BackwardGradientWorkspace`
/// * `NPRED` - prediction horizon
/// * `NUM_NODES` - total number of nodes
/// * `NUM_NONLEAF_NODES` - number of nonleaf nodes
///
pub fn total_cost_gradient_bw(
    x0: &[f64],
    u_at_node: &[f64],
    grad_stoc: &mut [f64],
    ws: &mut BackwardGradientWorkspace
) {

    ws.x_at_node[..NX].copy_from_slice(x0);
    /* simulation of state x[i] for all i in nodes(1, N) */
    for i in 1..=NUM_NODES - 1 {
        let x_anc_i = &ws.x_at_node[ANCESTOR_OF_NODE[i] * NX..(ANCESTOR_OF_NODE[i] + 1) * NX];
        let u_anc_i = &u_at_node[ANCESTOR_OF_NODE[i] * NU..(ANCESTOR_OF_NODE[i] + 1) * NU];
        let w_i = EVENT_AT_NODE[i];
        f(x_anc_i, u_anc_i, w_i, &mut ws.temp_nx_f);
        ws.x_at_node[i * NX..(i + 1) * NX].copy_from_slice(&ws.temp_nx_f);
    }

    /* calculate adjoint a[i] for all i in nodes(N) */
    let stage = NPRED;
    for i in NODES_AT_STAGE_FROM[stage]..=NODES_AT_STAGE_TO[stage] {
        let x_i = &ws.x_at_node[i * NX..(i + 1) * NX];
        let a_i = &mut ws.a_at_node[i * NX..(i + 1) * NX];
        vfx(x_i, a_i);
    }

    /* -------------------- backward method -------------------- */

    /* calculate gradient grad_stoc[i] and adjoint a[i] for all i in nodes(N-1) */
    let stage = NPRED - 1;
    for i in NODES_AT_STAGE_FROM[stage]..=NODES_AT_STAGE_TO[stage] {
        let grad_i = &mut grad_stoc[i * NU..(i + 1) * NU];
        let x_i = &ws.x_at_node[i * NX..(i + 1) * NX];
        let u_i = &u_at_node[i * NU..(i + 1) * NU];
        for j in CHILDREN_OF_NODE_FROM[i]..=CHILDREN_OF_NODE_TO[i] {
            let a_j = &mut ws.a_at_node[j * NX..(j + 1) * NX];
            let w_j = EVENT_AT_NODE[j];
            let pi_j = &PROBABILITY_AT_NODE[j];
            /* calculate gradient at node i */
            fu(x_i, u_i, a_j, w_j, &mut ws.temp_nu_f);
            ellu(x_i, u_i, w_j, &mut ws.temp_nu_ell);
            a_plus_eq_b(&mut ws.temp_nu_f, &ws.temp_nu_ell);
            a_times_eq_scalar_b(&mut ws.temp_nu_f, pi_j);
            a_plus_eq_b(grad_i, &ws.temp_nu_f);
            if NPRED > 1 {
                /* calculate adjoint at node i */
                fx(x_i, u_i, a_j, w_j, &mut ws.temp_nx_f);
                ellx(x_i, u_i, w_j, &mut ws.temp_nx_ell);
                a_plus_eq_b(&mut ws.temp_nx_f, &ws.temp_nx_ell);
                a_times_eq_scalar_b(&mut ws.temp_nx_f, pi_j);
                a_plus_eq_b(&mut ws.temp_nx_a, &ws.temp_nx_f);
            }
        }
        if NPRED > 1 {
            ws.a_at_node[i * NU..(i + 1) * NU].copy_from_slice(&ws.temp_nx_a);
            ws.temp_nx_a = vec![0.0; NX];
        }
    }

    /* if prediction horizon is greater than 2, continue, else skip */
    if NPRED > 2 {
        /* calculate gradient grad_stoc[i] and adjoint a[i] for all i in nodes(1, N-2) */
        for stage in (1..=NPRED - 2).rev() {
            for i in NODES_AT_STAGE_FROM[stage]..=NODES_AT_STAGE_TO[stage] {
                let grad_i = &mut grad_stoc[i * NU..(i + 1) * NU];
                let x_i = &ws.x_at_node[i * NX..(i + 1) * NX];
                let u_i = &u_at_node[i * NU..(i + 1) * NU];
                for j in CHILDREN_OF_NODE_FROM[i]..=CHILDREN_OF_NODE_TO[i] {
                    let a_j = &mut ws.a_at_node[j * NX..(j + 1) * NX];
                    let w_j = EVENT_AT_NODE[j];
                    let pi_j = &PROBABILITY_AT_NODE[j];
                    /* calculate gradient at node i */
                    fu(x_i, u_i, a_j, w_j, &mut ws.temp_nu_f);
                    ellu(x_i, u_i, w_j, &mut ws.temp_nu_ell);
                    a_times_eq_scalar_b(&mut ws.temp_nu_ell, pi_j);
                    a_plus_eq_b(&mut ws.temp_nu_f, &ws.temp_nu_ell);
                    a_plus_eq_b(grad_i, &ws.temp_nu_f);
                    /* calculate adjoint at node i */
                    fx(x_i, u_i, a_j, w_j, &mut ws.temp_nx_f);
                    ellx(x_i, u_i, w_j, &mut ws.temp_nx_ell);
                    a_times_eq_scalar_b(&mut ws.temp_nx_f, pi_j);
                    a_plus_eq_b(&mut ws.temp_nx_f, &ws.temp_nx_ell);
                    a_plus_eq_b(&mut ws.temp_nx_a, &ws.temp_nx_f);
                }
                ws.a_at_node[i * NU..(i + 1) * NU].copy_from_slice(&ws.temp_nx_a);
                ws.temp_nx_a = vec![0.0; NX];
            }
        }
    }

    /* if prediction horizon is greater than 1, continue, else finish */
    if NPRED > 1 {
        /* calculate gradient grad_stoc[0] and adjoint a[0] */
        let i = 0;
        let grad_i = &mut grad_stoc[i * NU..(i + 1) * NU];
        let x_i = &ws.x_at_node[i * NX..(i + 1) * NX];
        let u_i = &u_at_node[i * NU..(i + 1) * NU];
        for j in CHILDREN_OF_NODE_FROM[i]..=CHILDREN_OF_NODE_TO[i] {
            let a_j = &ws.a_at_node[j * NX..(j + 1) * NX];
            let w_j = EVENT_AT_NODE[j];
            let pi_j = &PROBABILITY_AT_NODE[j];
            /* calculate gradient at node i */
            fu(x_i, u_i, a_j, w_j, &mut ws.temp_nu_f);
            ellu(x_i, u_i, w_j, &mut ws.temp_nu_ell);
            a_times_eq_scalar_b(&mut ws.temp_nu_ell, pi_j);
            a_plus_eq_b(&mut ws.temp_nu_f, &ws.temp_nu_ell);
            a_plus_eq_b(grad_i, &ws.temp_nu_f);
        }
    }

}
