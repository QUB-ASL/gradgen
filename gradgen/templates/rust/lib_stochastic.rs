// This file is automatically generated by GradGen

use casadi_{{name}}::*;

/// Number of states
pub fn num_states() -> usize {
    return NX;
}

/// Number of inputs
pub fn num_inputs() -> usize {
    return NU;
}

#[derive(Debug)]
pub struct BackwardGradientWorkspace {
    pub(crate) r: Vec<f64>,
    pub x_at_node: Vec<f64>,
    pub a_at_node: Vec<f64>,
    pub(crate) temp_nx: Vec<f64>,
    pub(crate) temp_nu: Vec<f64>,
}

/// Workspace structure
impl BackwardGradientWorkspace {

    /// Create new instance of workspaces
    ///
    /// # Arguments
    ///
    /// * `r` - storage for state (NX) sized variable
    /// * `x_at_node` - vector of states: consists of state at node [index] for nodes(0, N)
    /// * `a_at_node` - vector of adjoints: consists of adjoint at node [index] for nodes(1, N)
    ///
    pub fn new(n_pred: usize) -> BackwardGradientWorkspace {
        BackwardGradientWorkspace {
            r: vec![0.0; NX],
            x_at_node: vec![0.0; NX * NUM_NODES],
            a_at_node: vec![0.0; NX * NUM_NODES],
            temp_nx: vec![0.0; NX],
            temp_nu: vec![0.0; NU],
        }
    }
}

fn a_plus_eq_b(a: &mut [f64], b: &[f64]) {
    a.iter_mut().zip(b.iter()).for_each(|(ai, bi)| *ai += *bi);
}

/// Gradient of the total stochastic cost function with backward method
///
/// # Arguments
///
/// * `x0` - initial state (state at node 0)
/// * `u_at_node` - vector of inputs: consists of input at node [index] for nodes(0, N-1)
/// * `grad_stoc` - gradient of total stochastic cost function (result)
/// * `ws` - workspace of type `BackwardGradientWorkspace`
/// * `NPRED` - prediction horizon
/// * `NUM_NODES` - total number of nodes
/// * `NUM_NONLEAF_NODES` - number of nonleaf nodes
///
pub fn total_cost_gradient_bw(
    x0: &[f64],
    u_at_node: &[f64],
    grad_stoc: &mut [f64],
    ws: &mut BackwardGradientWorkspace
) {

    ws.x_at_node[..NX].copy_from_slice(x0);
    /* simulation of state x[i] for all i in nodes(1, N) */
    for i in 1..=NUM_NODES - 1 {
        let x_anc_i = &ws.x_at_node[ANCESTOR_OF_NODE[i] * NX..(ANCESTOR_OF_NODE[i] + 1) * NX];
        let u_anc_i = &u_at_node[ANCESTOR_OF_NODE[i] * NU..(ANCESTOR_OF_NODE[i] + 1) * NU];
        let w_i = EVENT_AT_NODE[i];
        f(x_anc_i, u_anc_i, w_i, &mut ws.r);
        ws.x_at_node[i * NX..(i + 1) * NX].copy_from_slice(&ws.r);
    }

    /* a[i] for all i in nodes(N) */
    let stage = NPRED;
    for i in NODES_AT_STAGE_FROM[stage]..=NODES_AT_STAGE_TO[stage] {
        let x_i = &ws.x_at_node[i * NX..(i + 1) * NX];
        vfx(x_i, &mut ws.r);
        ws.a_at_node[i * NX..(i + 1) * NX].copy_from_slice(&ws.r);
    }

    /* grad_stoc[i] for all i in nodes(N-1) */
    let stage = NPRED - 1;
    for i in NODES_AT_STAGE_FROM[stage]..=NODES_AT_STAGE_TO[stage] {
        let x_i = &ws.x_at_node[i * NX..(i + 1) * NX];
        let u_i = &u_at_node[i * NU..(i + 1) * NU];
        for j in CHILDREN_OF_NODE_FROM[i]..=CHILDREN_OF_NODE_TO[i] {
            let a_j = &a_at_node[j * NX..(j + 1) * NX];
            let w_j = EVENT_AT_NODE[j];
            let pi_j = PROBABILITY_AT_NODE[j];
            ellu(x_i, u_i, w_j, &mut ws.temp_nu);
            jfu(x_i, u_i, a_j, w_j, &mut ws.temp_nx);
            ws.x_at_node[i * NX..(i + 1) * NX].copy_from_slice(&ws.r);
        }
    }

    /* backward method */
    for j in 1..=n-1 {
        let x_npred_j = &ws.x_at_node[(n - j) * NX..(n - j + 1) * NX];
        let u_npred_j = &u_at_node[(n - j) * NU..(n - j + 1) * NU];
        let grad_npred_j = &mut grad_stoc[(n - j) * NU..(n - j + 1) * NU];

        jfu(x_npred_j, u_npred_j, &ws.a, grad_npred_j);
        ellu(x_npred_j, u_npred_j, &mut ws.temp_nu);
        a_plus_eq_b(grad_npred_j, &ws.temp_nu);

        jfx(x_npred_j, u_npred_j, &ws.a, &mut ws.a_new);
        ellx(x_npred_j, u_npred_j, &mut ws.temp_nx);
        a_plus_eq_b(&mut ws.a_new, &ws.temp_nx);
        ws.a.copy_from_slice(&ws.a_new);
    }

    /* first coordinate (t=0) */
    let x_npred_j = &ws.x_at_node[0..NX];
    let u_npred_j = &u_at_node[0..NU];
    let grad_npred_j = &mut grad_stoc[..NU];

    jfu(x_npred_j, u_npred_j, &ws.a, grad_npred_j);
    ellu(x_npred_j, u_npred_j, &mut ws.temp_nu);
    a_plus_eq_b(grad_npred_j, &ws.temp_nu);

}